"""
# 문제 요약
- 함수 분석
    - n : 바닥의 길이
    - result : 타일을 채울 수 있는 방법의 개수
- 제한 사항
    - n은 5천 이하의 자연 수 
    - result는 1,000,000,007로 나눈 나머지
- 동작 사항
    - 2x1인 타일을 이용해 세로가 3, 가로가 n인 바닥을 채우기
    - 타일을 가로나 세로로 돌려가며 배치
# 문제 풀이
- 기존의 2 x n 타일링과 마찬가지로 동적 계획법을 이용합니다.
- 상향식 방법을 이용한 동적 계획법입니다.
- n = 2 => 3
- n = 4 => 11
    - 양쪽 2개씩 쪼개서 처리 가능 : dp[2] * dp[2]
    - 예시와 같이 추가한 특수 경우가 2개 생깁니다. 
    - 따라서, dp[2] * dp[2] + 2 = 11
- n = 6 => 41
    - 마찬가지로 n이 6인 경우의 특수한 경우 2개도 존재합니다. (n=4일 때 특수 경우를 옆으로 늘린 모양)
    - 쪼개기 가능
        - dp[4] * dp[2] => 33
        - dp[2] * dp[4] => 33
    - 쪼개기 시 4칸 2칸과 2칸 4칸일 때의 중복이 발생하기 때문에 사용이 불가합니다.
    - 하지만 4인 경우에만발 생하는 특수 패턴 2가지는 중복되지 않을 것으로 dp[2] * (2가지 특수 패턴)을 통해서 추가 획득 가능
        - dp[4] * dp[2]는 4칸짜리 조합에 2칸짜리 조합을 붙여서 구성
        - dp[2] * dp[4]는 뒤의 dp[4]에 기존에 없던 특수 모양을 붙여야만 새로운 조합을 구성할 수 있음
        - 따라서 dp[2] * <n=4> => 3 * 2 => 6
    - 특수 패턴의 표기 : <n=4>
    - 정리
        - dp[4] * dp[3] => 33
        - n이 6인 경우 추가 패턴 => 2
        - n이 4인 경우 추가 패턴의 중복되지 않는 경우 => dp[2] * <n=4> => 6
- n = 8 => 153
    - dp[6] * dp[2] => 123
    - dp[4] * dp[4] 에서 신규 목록 => dp[4] * <n=4> => 22
        - dp[4] 조합에 dp[4]에서만 구할 수 있는 특수 조합을 붙여야만 구성
    - dp[2] * dp[6] 에서 신규 목록 => dp[2] * <n=6> => 6
    - n = 8의 특수 패턴 => 2
- 점화식 구성(n > 2)
    - dp[n] = dp[n - 2] * dp[2] + (dp[n - 4] * 2 + dp[n - 6] * 2 + ... dp[2] * 2) + 2
- 점화식 개선(n > 2) 
    - 기존 점화식은 O(N^2)로 느립니다.
    - 마지막 + 2를 특수 패턴과 합칩니다. : dp[n] = dp[n - 2] * dp[2] + (dp[n - 4] * 2 + dp[n - 6] * 2 + ... dp[2] * 2 + 1 * 2)
    - (0인 경우를 1로 삼은 것과 마찬가지로 처리가 됩니다.)
    - 따라서, dp[n] = dp[n-2] * dp[2] + (dp[n-4] + ... + dp[0]) * 2 = dp[n-2] * 3 + (dp[n-4] + ... + dp[0]) * 2
    - 양변에 dp[n-2]를 뻬줍니다.
    - dp[n] - dp[n-2] = dp[n-2] * 2 + (dp[n-4] + ... + dp[0]) * 2
    - dp[n] - dp[n-2] = (dp[n-2] + ... + dp[0]) * 2
    - 이를 극한으로 정리하면 다음과 같이 정리가 가능
    - 새 점화식 : dp[n] = 4 * dp[n-2] - dp[n-4]
"""
def solution(n):
    INF = 1_000_000_007
    
    if n % 2 != 0: # 홀수인 경우 구성 불가 예외 처리
        return 0
    
    answer = 0
    dp_list = [1, 3, 11] # S(0)은 사용하지 않지만 1로 두어 식 구성의 편리성을 더함, 짝수만 리스트로 사용
    for ii in range(3, n // 2 + 1): # n이 짝수므로 n//2를 통해서 ii를 진행, n까지 반복이라 n//2 + 1까지로 설정
        # 짝수만 사용하므로 모든 idx 상수는 //2 처리 상태
        dp_list.append(dp_list[ii - 1] * 4 - dp_list[ii - 2]) # 정리한 점화식 : dp[n] = 4 * dp[n-2] - dp[n-4]
        
    answer = dp_list[-1] # 마지막 값 반환
    return answer % INF # 결과 처리 전 숫자를 줄이기